{"version":3,"file":"track.js","sourceRoot":"","sources":["../../src/music/track.ts"],"names":[],"mappings":";;;AAAA,yCAAoC;AACpC,4CAAkF;AAClF,qDAA8C;AAa9C,gEAAgE;AAChE,MAAM,IAAI,GAAG,GAAG,EAAE,GAAE,CAAC,CAAC;AAEtB;;;;;;;;GAQG;AACH,MAAa,KAAK;IAOjB,YAAoB,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAa;QACxE,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACxB,CAAC;IAED;;OAEG;IACI,mBAAmB;QACzB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACtC,MAAM,OAAO,GAAG,qBAAI,CACnB,IAAI,CAAC,GAAG,EACR;gBACC,CAAC,EAAE,GAAG;gBACN,CAAC,EAAE,EAAE;gBACL,CAAC,EAAE,qDAAqD;gBACxD,CAAC,EAAE,MAAM;aACT,EACD,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,MAAM,EAAE,QAAQ,CAAC,EAAE,CACvC,CAAC;YACF,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;gBACpB,MAAM,CAAC,IAAI,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC;gBAC/B,OAAO;aACP;YACD,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;YAC9B,MAAM,OAAO,GAAG,CAAC,KAAY,EAAE,EAAE;gBAChC,IAAI,CAAC,OAAO,CAAC,MAAM;oBAAE,OAAO,CAAC,IAAI,EAAE,CAAC;gBACpC,MAAM,CAAC,MAAM,EAAE,CAAC;gBAChB,MAAM,CAAC,KAAK,CAAC,CAAC;YACf,CAAC,CAAC;YACF,OAAO;iBACL,IAAI,CAAC,OAAO,EAAE,GAAG,EAAE;gBACnB,kBAAU,CAAC,MAAM,CAAC;qBAChB,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,OAAO,CAAC,2BAAmB,CAAC,KAAK,CAAC,MAAM,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;qBACtG,KAAK,CAAC,OAAO,CAAC,CAAC;YAClB,CAAC,CAAC;iBACD,KAAK,CAAC,OAAO,CAAC,CAAC;QAClB,CAAC,CAAC,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAW,EAAE,OAAwD;QAC7F,MAAM,IAAI,GAAG,MAAM,mBAAO,CAAC,GAAG,CAAC,CAAC;QAEhC,gFAAgF;QAChF,MAAM,cAAc,GAAG;YACtB,OAAO;gBACN,cAAc,CAAC,OAAO,GAAG,IAAI,CAAC;gBAC9B,OAAO,CAAC,OAAO,EAAE,CAAC;YACnB,CAAC;YACD,QAAQ;gBACP,cAAc,CAAC,QAAQ,GAAG,IAAI,CAAC;gBAC/B,OAAO,CAAC,QAAQ,EAAE,CAAC;YACpB,CAAC;YACD,OAAO,CAAC,KAAY;gBACnB,cAAc,CAAC,OAAO,GAAG,IAAI,CAAC;gBAC9B,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YACxB,CAAC;SACD,CAAC;QAEF,OAAO,IAAI,KAAK,CAAC;YAChB,KAAK,EAAE,IAAI,CAAC,YAAY,CAAC,KAAK;YAC9B,GAAG;YACH,GAAG,cAAc;SACjB,CAAC,CAAC;IACJ,CAAC;CACD;AAlFD,sBAkFC","sourcesContent":["import { getInfo } from 'ytdl-core';\nimport { AudioResource, createAudioResource, demuxProbe } from '@discordjs/voice';\nimport { raw as ytdl } from 'youtube-dl-exec';\n\n/**\n * This is the data required to create a Track object\n */\nexport interface TrackData {\n\turl: string;\n\ttitle: string;\n\tonStart: () => void;\n\tonFinish: () => void;\n\tonError: (error: Error) => void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {};\n\n/**\n * A Track represents information about a YouTube video (in this context) that can be added to a queue.\n * It contains the title and URL of the video, as well as functions onStart, onFinish, onError, that act\n * as callbacks that are triggered at certain points during the track's lifecycle.\n *\n * Rather than creating an AudioResource for each video immediately and then keeping those in a queue,\n * we use tracks as they don't pre-emptively load the videos. Instead, once a Track is taken from the\n * queue, it is converted into an AudioResource just in time for playback.\n */\nexport class Track implements TrackData {\n\tpublic readonly url: string;\n\tpublic readonly title: string;\n\tpublic readonly onStart: () => void;\n\tpublic readonly onFinish: () => void;\n\tpublic readonly onError: (error: Error) => void;\n\n\tprivate constructor({ url, title, onStart, onFinish, onError }: TrackData) {\n\t\tthis.url = url;\n\t\tthis.title = title;\n\t\tthis.onStart = onStart;\n\t\tthis.onFinish = onFinish;\n\t\tthis.onError = onError;\n\t}\n\n\t/**\n\t * Creates an AudioResource from this Track.\n\t */\n\tpublic createAudioResource(): Promise<AudioResource<Track>> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst process = ytdl(\n\t\t\t\tthis.url,\n\t\t\t\t{\n\t\t\t\t\to: '-',\n\t\t\t\t\tq: '',\n\t\t\t\t\tf: 'bestaudio[ext=webm+acodec=opus+asr=48000]/bestaudio',\n\t\t\t\t\tr: '100K',\n\t\t\t\t},\n\t\t\t\t{ stdio: ['ignore', 'pipe', 'ignore'] },\n\t\t\t);\n\t\t\tif (!process.stdout) {\n\t\t\t\treject(new Error('No stdout'));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst stream = process.stdout;\n\t\t\tconst onError = (error: Error) => {\n\t\t\t\tif (!process.killed) process.kill();\n\t\t\t\tstream.resume();\n\t\t\t\treject(error);\n\t\t\t};\n\t\t\tprocess\n\t\t\t\t.once('spawn', () => {\n\t\t\t\t\tdemuxProbe(stream)\n\t\t\t\t\t\t.then((probe) => resolve(createAudioResource(probe.stream, { metadata: this, inputType: probe.type })))\n\t\t\t\t\t\t.catch(onError);\n\t\t\t\t})\n\t\t\t\t.catch(onError);\n\t\t});\n\t}\n\n\t/**\n\t * Creates a Track from a video URL and lifecycle callback methods.\n\t *\n\t * @param url The URL of the video\n\t * @param methods Lifecycle callbacks\n\t * @returns The created Track\n\t */\n\tpublic static async from(url: string, methods: Pick<Track, 'onStart' | 'onFinish' | 'onError'>): Promise<Track> {\n\t\tconst info = await getInfo(url);\n\n\t\t// The methods are wrapped so that we can ensure that they are only called once.\n\t\tconst wrappedMethods = {\n\t\t\tonStart() {\n\t\t\t\twrappedMethods.onStart = noop;\n\t\t\t\tmethods.onStart();\n\t\t\t},\n\t\t\tonFinish() {\n\t\t\t\twrappedMethods.onFinish = noop;\n\t\t\t\tmethods.onFinish();\n\t\t\t},\n\t\t\tonError(error: Error) {\n\t\t\t\twrappedMethods.onError = noop;\n\t\t\t\tmethods.onError(error);\n\t\t\t},\n\t\t};\n\n\t\treturn new Track({\n\t\t\ttitle: info.videoDetails.title,\n\t\t\turl,\n\t\t\t...wrappedMethods,\n\t\t});\n\t}\n}\n"]}
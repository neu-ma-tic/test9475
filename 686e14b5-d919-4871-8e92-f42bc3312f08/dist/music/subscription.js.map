{"version":3,"file":"subscription.js","sourceRoot":"","sources":["../../src/music/subscription.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tAudioPlayer,\n\tAudioPlayerStatus,\n\tAudioResource,\n\tcreateAudioPlayer,\n\tentersState,\n\tVoiceConnection,\n\tVoiceConnectionDisconnectReason,\n\tVoiceConnectionStatus,\n} from '@discordjs/voice';\nimport { Track } from './track';\nimport { promisify } from 'util';\n\nconst wait = promisify(setTimeout);\n\n/**\n * A MusicSubscription exists for each active VoiceConnection. Each subscription has its own audio player and queue,\n * and it also attaches logic to the audio player and voice connection for error handling and reconnection logic.\n */\nexport class MusicSubscription {\n\tpublic readonly voiceConnection: VoiceConnection;\n\tpublic readonly audioPlayer: AudioPlayer;\n\tpublic queue: Track[];\n\tpublic queueLock = false;\n\tpublic readyLock = false;\n\n\tpublic constructor(voiceConnection: VoiceConnection) {\n\t\tthis.voiceConnection = voiceConnection;\n\t\tthis.audioPlayer = createAudioPlayer();\n\t\tthis.queue = [];\n\n\t\tthis.voiceConnection.on('stateChange', async (_, newState) => {\n\t\t\tif (newState.status === VoiceConnectionStatus.Disconnected) {\n\t\t\t\tif (newState.reason === VoiceConnectionDisconnectReason.WebSocketClose && newState.closeCode === 4014) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tIf the WebSocket closed with a 4014 code, this means that we should not manually attempt to reconnect,\n\t\t\t\t\t\tbut there is a chance the connection will recover itself if the reason of the disconnect was due to\n\t\t\t\t\t\tswitching voice channels. This is also the same code for the bot being kicked from the voice channel,\n\t\t\t\t\t\tso we allow 5 seconds to figure out which scenario it is. If the bot has been kicked, we should destroy\n\t\t\t\t\t\tthe voice connection.\n\t\t\t\t\t*/\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait entersState(this.voiceConnection, VoiceConnectionStatus.Connecting, 5_000);\n\t\t\t\t\t\t// Probably moved voice channel\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthis.voiceConnection.destroy();\n\t\t\t\t\t\t// Probably removed from voice channel\n\t\t\t\t\t}\n\t\t\t\t} else if (this.voiceConnection.rejoinAttempts < 5) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe disconnect in this case is recoverable, and we also have <5 repeated attempts so we will reconnect.\n\t\t\t\t\t*/\n\t\t\t\t\tawait wait((this.voiceConnection.rejoinAttempts + 1) * 5_000);\n\t\t\t\t\tthis.voiceConnection.rejoin();\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe disconnect in this case may be recoverable, but we have no more remaining attempts - destroy.\n\t\t\t\t\t*/\n\t\t\t\t\tthis.voiceConnection.destroy();\n\t\t\t\t}\n\t\t\t} else if (newState.status === VoiceConnectionStatus.Destroyed) {\n\t\t\t\t/*\n\t\t\t\t\tOnce destroyed, stop the subscription\n\t\t\t\t*/\n\t\t\t\tthis.stop();\n\t\t\t} else if (\n\t\t\t\t!this.readyLock &&\n\t\t\t\t(newState.status === VoiceConnectionStatus.Connecting || newState.status === VoiceConnectionStatus.Signalling)\n\t\t\t) {\n\t\t\t\t/*\n\t\t\t\t\tIn the Signalling or Connecting states, we set a 20 second time limit for the connection to become ready\n\t\t\t\t\tbefore destroying the voice connection. This stops the voice connection permanently existing in one of these\n\t\t\t\t\tstates.\n\t\t\t\t*/\n\t\t\t\tthis.readyLock = true;\n\t\t\t\ttry {\n\t\t\t\t\tawait entersState(this.voiceConnection, VoiceConnectionStatus.Ready, 20_000);\n\t\t\t\t} catch {\n\t\t\t\t\tif (this.voiceConnection.state.status !== VoiceConnectionStatus.Destroyed) this.voiceConnection.destroy();\n\t\t\t\t} finally {\n\t\t\t\t\tthis.readyLock = false;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Configure audio player\n\t\tthis.audioPlayer.on('stateChange', (oldState, newState) => {\n\t\t\tif (newState.status === AudioPlayerStatus.Idle && oldState.status !== AudioPlayerStatus.Idle) {\n\t\t\t\t// If the Idle state is entered from a non-Idle state, it means that an audio resource has finished playing.\n\t\t\t\t// The queue is then processed to start playing the next track, if one is available.\n\t\t\t\t(oldState.resource as AudioResource<Track>).metadata.onFinish();\n\t\t\t\tvoid this.processQueue();\n\t\t\t} else if (newState.status === AudioPlayerStatus.Playing) {\n\t\t\t\t// If the Playing state has been entered, then a new track has started playback.\n\t\t\t\t(newState.resource as AudioResource<Track>).metadata.onStart();\n\t\t\t}\n\t\t});\n\n\t\tthis.audioPlayer.on('error', (error) => (error.resource as AudioResource<Track>).metadata.onError(error));\n\n\t\tvoiceConnection.subscribe(this.audioPlayer);\n\t}\n\n\t/**\n\t * Adds a new Track to the queue.\n\t *\n\t * @param track The track to add to the queue\n\t */\n\tpublic enqueue(track: Track) {\n\t\tthis.queue.push(track);\n\t\tvoid this.processQueue();\n\t}\n\n\t/**\n\t * Stops audio playback and empties the queue\n\t */\n\tpublic stop() {\n\t\tthis.queueLock = true;\n\t\tthis.queue = [];\n\t\tthis.audioPlayer.stop(true);\n\t}\n\n\t/**\n\t * Attempts to play a Track from the queue\n\t */\n\tprivate async processQueue(): Promise<void> {\n\t\t// If the queue is locked (already being processed), is empty, or the audio player is already playing something, return\n\t\tif (this.queueLock || this.audioPlayer.state.status !== AudioPlayerStatus.Idle || this.queue.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\t// Lock the queue to guarantee safe access\n\t\tthis.queueLock = true;\n\n\t\t// Take the first item from the queue. This is guaranteed to exist due to the non-empty check above.\n\t\tconst nextTrack = this.queue.shift()!;\n\t\ttry {\n\t\t\t// Attempt to convert the Track into an AudioResource (i.e. start streaming the video)\n\t\t\tconst resource = await nextTrack.createAudioResource();\n\t\t\tthis.audioPlayer.play(resource);\n\t\t\tthis.queueLock = false;\n\t\t} catch (error) {\n\t\t\t// If an error occurred, try the next item of the queue instead\n\t\t\tnextTrack.onError(error as Error);\n\t\t\tthis.queueLock = false;\n\t\t\treturn this.processQueue();\n\t\t}\n\t}\n}\n"]}